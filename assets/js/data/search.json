[ { "title": "Leveraging SerializeReference for Flexible Commands in Unity Game Development", "url": "/posts/Leveraging-SerializeReference-for-Flexible-Commands-in-Unity-Game-Development/", "categories": "Unity", "tags": "Unity, UniRx, Intermediate, Advanced", "date": "2023-08-11 00:00:00 +0200", "snippet": "IntroductionIn the fast-paced world of game development, time is often a precious commodity. Finding efficient solutions that offer quick testing and flexible configuration becomes paramount. We, too, faced this challenge and discovered a potent approach that not only met these demands but also allowed us to customize our domain’s behavior extensively.Our secret weapon? The SerializeReference attribute coupled with a tailored Condition/Command pattern. While our exploration of this technique is still ongoing, the preliminary results are incredibly promising. We’re excited to share our insights and invite you to join the conversation.If you’re curious about the base capabilities of SerializeReference, check out this basic yet powerful example in Reddit thread.Let’s dive into the tools that helped us craft this solution: UniTask: A free library offering efficient allocation-free async/await integration for Unity. OdinInspector: A library that facilitates instance creation from dropdowns using the SerializeReference attribute (You can also create custom editors or explore alternatives like Unity-SerializeReferenceExtensions). These tools emphasize the use of Commands through SerializeReference, with a special nod to the added brilliance when employing async/await principles.Unleashing Commands:But what exactly are these “commands” we keep referring to? In essence, commands are serializable configurations of actions that can be executed within a given context. They’re like the building blocks of dynamic behavior in your game.public interface ICommand&amp;lt;TContext&amp;gt;{ UniTask ExecuteAsync(TContext context, CancellationToken cancellationToken);}Let’s explore some examples:Simple Contextual Commands for Character Behavior:public class RestoreHPCharacterCommand : ICharacterCommand{ public UniTask Execute(Character context, CancellationToken cancellationToken) { context.RestoreHP(); return UniTask.CompletedTask; }}public class ModifyStatisticCharacterCommand : ICharacterCommand{ public Id StatisticId; public float Value; public UniTask Execute(Character context, CancellationToken cancellationToken) { context.GetStatistic(StatisticId).ModifyBy(Value); return UniTask.CompletedTask; }}Versatile Commands for Any GameObject:Behold an asynchronous command example:public class MoveGameObjectCommand : IGameObjectCommand{ public Vector3 Direction; public float Duration; public float Distance; public async UniTask Execute(GameObject context, CancellationToken cancellationToken) { var startTime = Time.time; var initialPosition = context.transform.position; var targetPosition = initialPosition + Direction.normalized * Distance; while (Time.time - startTime &amp;lt; Duration) { float progress = (Time.time - startTime) / Duration; context.transform.position = Vector3.Lerp(initialPosition, targetPosition, progress); await UniTask.Yield(PlayerLoopTiming.Update, cancellationToken: cancellationToken); } context.transform.position = targetPosition; }}Building Blocks with Boilerplate Commands:Meet the Command Group—a highly useful construct enabling the execution of multiple commands in parallel or sequentially:public class CommandGroup&amp;lt;TCommand, TContext&amp;gt; : ICommand&amp;lt;TContext&amp;gt; where TCommand : ICommand&amp;lt;TContext&amp;gt;{ public List&amp;lt;CommandSetup&amp;gt; Commands = new(); public bool ExecuteInParallel = true; public async UniTask ExecuteAsync(TContext context, CancellationToken cancellationToken) { if (ExecuteInParallel) { await UniTask.WhenAll(Commands.Select(item =&amp;gt; item.ExecuteAsync(context, cancellationToken))); return; } foreach (var item in Commands) { await item.ExecuteAsync(context, cancellationToken); } }}Enter the Delay Command—perfect for orchestrating pauses between command executions:public class DelayCommand&amp;lt;TContext&amp;gt; : ICommand&amp;lt;TContext&amp;gt;{ public float DelayMs; public UniTask ExecuteAsync(TContext context, CancellationToken cancellationToken) { return UniTask.Delay(TimeSpan.FromMilliseconds(DelayMs), cancellationToken: cancellationToken); }}Bridge the Unity world with the UnityEventCommand, facilitating actions like starting particle systems or toggling game objects:public class UnityEventCommand&amp;lt;TCommand, TContext&amp;gt; : ICommand&amp;lt;TContext&amp;gt; where TCommand : ICommand&amp;lt;TContext&amp;gt;{ public UnityEvent Event; public UniTask ExecuteAsync(TContext context, CancellationToken cancellationToken) { Event?.Invoke(); return UniTask.CompletedTask; }}Conditions: Expanding Behavior HorizonsConditions are an integral piece of the puzzle, perfectly complementing the concept of commands. With conditions, we can create complex behaviors by weaving together simple atomic actions. This enables us to craft dynamic and nuanced gameplay experiences, allowing our games to react intelligently to a variety of scenarios.What Are Conditions in the Context of Commands?Conditions are logic checks that determine whether a certain command or set of commands should be executed based on the state of the game. This powerful addition allows us to create decision branches that respond dynamically to the gameplay context.public interface ICondition&amp;lt;TContext&amp;gt;{ UniTask&amp;lt;bool&amp;gt; ExecuteAsync(TContext context, CancellationToken cancellationToken);}Examples of Condition-Driven Behavior: If a character’s HP drops to 0, execute the PlayFeedbacksCommand. Depending on the damage severity from a DamageInfo context, trigger either a Critical Effect or a Default Effect. If the DamageType is Fire, apply fire-related effects. If the MagicShield’s energy level is above 50%, enable the HighEnergy Effect and disable the LowEnergy Effect.Creating Condition Groups: All or AnyTo harness the full potential of conditions, we can group them together to create more intricate decision-making structures. These groups allow us to determine whether all conditions must be met before executing a command or if just a single condition suffices.public class ConditionGroup&amp;lt;TCondition, TContext&amp;gt; : ICondition&amp;lt;TContext&amp;gt; where TCondition : ICondition&amp;lt;TContext&amp;gt;{ public enum GroupType { All, Any } [EnumToggleButtons] public GroupType Type; [SerializeReference] public List&amp;lt;TCondition&amp;gt; Conditions = new(); public async UniTask&amp;lt;bool&amp;gt; ExecuteAsync(TContext context, CancellationToken cancellationToken) { if (Type == GroupType.All) { foreach (var condition in Conditions) { if (!await condition.ExecuteAsync(context, cancellationToken)) return false; } return true; } else if (Type == GroupType.Any) { foreach (var condition in Conditions) { if (await condition.ExecuteAsync(context, cancellationToken)) return true; } return false; } return false; }}Condition-Driven Command ExecutionThe synergy between conditions and commands allows us to craft more sophisticated behaviors. The ConditionCommand enables us to execute specific commands based on whether a condition is met or not. This adds a layer of intelligence to our gameplay, making it react dynamically to the context.public class ConditionCommand&amp;lt;TCondition, TCommand, TContext&amp;gt; : ICommand&amp;lt;TContext&amp;gt; where TCommand : ICommand&amp;lt;TContext&amp;gt; where TCondition : ICondition&amp;lt;TContext&amp;gt;{ [SerializeReference] public TCondition Condition; [SerializeReference] public TCommand Command; [SerializeReference] public TCommand ElseCommand; public async UniTask ExecuteAsync(TContext context, CancellationToken cancellationToken) { var result = await Condition.ExecuteAsync(context, cancellationToken); if (result) { if (Command == null) return; await Command.ExecuteAsync(context, cancellationToken); } else { if (ElseCommand == null) return; await ElseCommand.ExecuteAsync(context, cancellationToken); } }}Pros and Cons:Pros: Modularity Reusability Easy configuration of new behaviors Exceptionally flexible solution accommodating various scenarios Leveraging presets for streamlined developmentCons: Potential complexity in inspector-side configuration Involvement of boilerplate code Dependency injection challengesSummaryIn the dynamic realm of Unity game development, integrating SerializeReference, the Command pattern, and Conditions isn’t just a fancy idea; it’s a game-changer. This trifecta offers tangible benefits that can transform your game development process: Flexibility Unleashed: Embrace the power to mold behaviors on the fly. Whether it’s character actions, environmental responses, or narrative twists, this approach adapts to your creative whims. Efficiency Amplified: Streamline your workflow with a unified toolkit. No need to reinvent the wheel for every system; these tools seamlessly integrate across components and ScriptableObjects. Engagement Elevated: Craft gameplay that reacts to players choices and actions. From immersive weather shifts to intricate dialogue trees, this approach enhances player immersion and investment. Reusability Simplified: Create components and behaviors that can be easily reused across your project. Save time and effort while maintaining consistent and polished gameplay elements. Innovation Unlocked: Experiment with combinations and possibilities that breathe life into your game. The synergy between these techniques sparks innovation and elevates your game above the ordinary. So, as you embark on your next Unity adventure, remember that the fusion of SerializeReference, the Command pattern, and Conditions isn’t just a theory—it’s a practical gateway to a richer, more responsive, and thoroughly enjoyable game development journey. Start integrating these tools, watch your game thrive, and relish in the joy of creating something truly exceptional. Your game awaits its transformation!Resources UniRx Library Odin Inspector" }, { "title": "Watchers", "url": "/posts/Watchers/", "categories": "Unity", "tags": "Unity, UniRx, Beginner, Intermediate, Advanced", "date": "2022-06-11 00:00:00 +0200", "snippet": "IntroductionHave you ever struggled with jumping from tab to tab, from window to window? Are you tired of the endless journey through the object hierarchy to find the right one? Are you tired of scrolling through countless logs to keep track of that one specific value?If you answered yes to any of the above questions, You’ve come to the right place! Jokes aside, in this post we would like to introduce our custom tool called Watchers.Watchers is a collection of handy windows and extensions that will speed up your workflow and make your life easier.Why Watchers most frequently used objects in one place and always at hand tracking values of not only UnityEngine.Objects, but also instance values of ordinary classes easiness of use high extensibility native solution customizable solution with support for your own stylesUnity InstallationSince unity doesn’t support git dependencies in package.json you have to install UniRx manually.Edit manifest.json file in your Unity Packages directory{ &quot;dependencies&quot;: { &quot;com.gbros.tools.unirx.powerobservables&quot;: &quot;[&amp;lt;https://github.com/GbrosGames/Tools.git?path=Assets/Watchers&amp;gt;](&amp;lt;https://github.com/GbrosGames/Tools.git?path=Assets/Watchers&amp;gt;)&quot;, &quot;com.neuecc.unirx&quot;: &quot;[&amp;lt;https://github.com/neuecc/UniRx.git?path=Assets/Plugins/UniRx/Scripts&amp;gt;](&amp;lt;https://github.com/neuecc/UniRx.git?path=Assets/Plugins/UniRx/Scripts&amp;gt;)&quot; }}GeneralWatchers are created from bunch of UnityEngine.UIElements and UnityEditor.UIElements. Please see blow for detailed introduction to all core classes, methods and use case examples.WatchersWatcher is a base class that holds references to the boards. It’s responsible for clearing all subscriptions on the board. Every watcher can contain multiple boards.BoardsBoard inherits from Unity native GraphView. It is a place where you can add your Nodes. Boards can contain multiple cards.CardCard inherits from Unity native Node. It is the element that can be part of our Graph. You can create and add your custom nodes. Cards are used as data containers.ContainerContainer is styled UIElement with label that can have many UI Elements.It can be easily extended with your own UIElements and stylized through the Watchers API or with custom .uss files.Getting StartedSince watchers is editor only solution to help you with debugging and increase your development speed we have to add proper usings at the top of the class.#if UNITY_EDITORusing Gbros.Watchers;#endifCreating WatcherFluent way[Serializable] public class SomeClass { public Color SomeColor; public string SomeText;}public class SomeNotUnityObjectClass{ public int SomeValue { get; set; }}public class SomeComponent : MonoBehaviour {public int SomeValue = 2;public Vector2 SomeVector2 = Vector2.up;public Vector3 SomeVector3 = Vector3.up;public SomeClass SomeClass;private void Awake(){ var someNotUnityObjectClass = new SomeNotUnityObjectClass { SomeValue = 123 }; #if UNITY_EDITOR Watchers.Watcher(&quot;Watcher A&quot;) .Board(&quot;Board A&quot;) .Card(&quot;Card A&quot;) .Container(&quot;Container A&quot;) .AddSelectorButton($&quot;Select {gameObject.name}&quot;, gameObject) .AddSerializedProperty(this, x =&amp;gt; x.SomeValue) .AddSerializedProperty(this, &quot;SomeVector2&quot;) .AddSerializedProperty(this, x =&amp;gt; x.SomeVector3) .AddSerializedProperty(this, x =&amp;gt; x.SomeClass) .AddProperty(&quot;SomeValue in someNonSerializableClass&quot;, someNotUnityObjectClass, x =&amp;gt; x.SomeValue, x =&amp;gt; someNotUnityObjectClass.SomeValue = x) .AddActionButton(&quot;Some Action&quot;, () =&amp;gt; { Debug.Log($&quot;Value from nonUnityObjectClass - {someNotUnityObjectClass.SomeValue}&quot;); }); #endif}Classic var watcher = Watchers.Watcher(&quot;Watcher A&quot;); var board = watcher.Board(&quot;Board A&quot;); var card = board.Card(&quot;Card A&quot;); var cardContainer = card.Container(&quot;Container A&quot;); // add whatever VisualElement to your cardContainerNestedWatchers.Watcher(&quot;Watcher C&quot;).Board(&quot;Board A&quot;, board =&amp;gt; { board.Card(&quot;Card A&quot;, card =&amp;gt; { card.Container(&quot;Container A&quot;) .AddActionButton(&quot;Click me&quot;, () =&amp;gt; Debug.Log(&quot;Hello World&quot;)); card.Container(&quot;Container B&quot;) .Add(&quot;GeneralInfoKey&quot;, new Label(&quot;General Info&quot;), label =&amp;gt; label.style.color = Color.yellow) .AddProperty(nameof(SomeValue), this, x =&amp;gt; x.SomeValue, x =&amp;gt; SomeValue = x); }); board.Card(&quot;Card B&quot;);});Watcher UI ElementsSelector ButtonsExtension that adds button which will find your object in the scene hierarchy. It is setting Selection.activeObject under the hood.AddSelectorButton($&quot;Select {gameObject.name}&quot;, gameObject)Action ButtonsExtension that adds button with an action. Really useful for testing!.AddActionButton(&quot;Click me&quot;, () =&amp;gt; Debug.Log(&quot;Hello World&quot;));PropertiesAdd various kind of properties to your UI elementsSerializedPropertySerialized properties can be invoked on UnityEngine.Objects like Components/MonoBehaviours/ScriptableObjects.It will be displayed in the same way as in the inspector..AddSerializedProperty(this, x =&amp;gt; x.SomeClass) PropertyNormal properties can be added through few handy overloads. Under the hood every property is a field from UI Elements that has been created for certain types like ints, floats, bools, Vector2s, Vector3sThe most generic way:1) Getter/SetterIt will observe every value changed of a selected property.AddProperty(&quot;PropertyName&quot;, this, x =&amp;gt; x.SomeValue, x =&amp;gt; SomeValue = x) .AddProperty(1, 2, 3, 4)1 - display name of the property2 - property context, for example class where it is used3 - getter from the context4 - setter for the property. Is not required, but if you want to have two way binding you have to use it.2) Observable way.AddProperty(nameof(ReactiveProperty), ReactiveProperty);.AddProperty(1, 2)1 - display name of the property2 - IReactiveProperty / IObservableStylingUSSThere are two ways of styling your watchers. The first one is to use classic stylesheetsRMB on active folder -&amp;gt; Create -&amp;gt; Watchers StylesheetIt will create base stylesheet with initial setup that you can work on.Next create initializer script somewhere in your solution and point it to the Path where you have created your Stylesheet.public class WatcherInitializer{ [RuntimeInitializeOnLoadMethod(RuntimeInitializeLoadType.AfterAssembliesLoaded)] public static void Initialize() { Watchers.EditorStylePath = &quot;Assets/MyStyles.uss&quot;; }}Inline stylesWatcher cards and boards inherits from VisualElements so you can set inline styles like soelement.style.color = Color.green;In case you want to use fluent API, watcher elements have their own callbacks.Property(&quot;SomeValue&quot;, this, x =&amp;gt; x.SomeValue, x =&amp;gt; SomeValue = x).Configure(field =&amp;gt; field.style.borderWidth = 5);or shorter version:.Property(&quot;SomeValue&quot;, this, x =&amp;gt; x.SomeValue, x =&amp;gt; SomeValue = x, field =&amp;gt; field.style.borderWidth = 5);Watchers .Watcher() .Board() .Card(&quot;PRO CARD&quot;, card =&amp;gt; { card.Title.style.color = Color.yellow; card.style.backgroundColor = Color.blue; })Unity ExamplesAll code samples can be found on our GitHub pageExample 1Where To Go From HerePowerObservablesResourcesUniRx Library" }, { "title": "UniRx — PowerObservables", "url": "/posts/UniRx-PowerObservables/", "categories": "Unity", "tags": "Unity, UniRx, Intermediate", "date": "2021-07-21 00:00:00 +0200", "snippet": "Prerequisites Familiar with Observer pattern Hands on any Rx libraryIntroductionPowerObservables are set of time-based operations with ability to pause and possibility to manage tick freqeuencyWhy Power Observables Easy access to time-based operations Timers / Countdowns based on TimeSpans Ability to pause an observable using another observable (i.e. BoolReactiveProperty)Power ObservablesCountdownObservable sequence that produces a differed time value for certain duration with ability to pause and resume. Completes when there is no time left.It’s pretty usefull when it comes to Limit time in Arcade Games Countdown before race start when you want to prompt “3, 2, 1, GO” Damage overtime — every tick deal 10 damage to player, on complete remove debuffPowerObservable .Countdown(Time) .Subscribe(OnTick, OnComplete) .AddTo(this);Sequence: Countdown(3) → 2 → 1 → done with 3rd tickTimerIntervalObservable sequence that produces a value after each period for certain duration with ability to pause.PowerObservable .TimerInterval(Time) .Subscribe(OnTick, OnComplete) .AddTo(this);Sequence: TimerInterval(3) → 1 → 1 → done with 3rd tickCountedIntervalReturns an observable sequence with aggregated time since subscribe with pause optionPowerObservable .TimerInterval(Time) .Subscribe(OnTick, OnComplete) .AddTo(this);Sequence: CountedInterval() → 1 → 2 → 3 → 4 → 5…TimerCountedIntervalReturns an observable sequence with aggregated time since subscribe. Lasts for certain duration. It’s the same concept as Countdown but reversed. Instead times go up from zero. It completes after certain duration.PowerObservable .TimerInterval(Time) .Subscribe(OnTick, OnComplete) .AddTo(this); Sequence: TimerCountedInterval(3) → 1 → 2 → done with 3rd tickHow To UseSimple use case scenario below:var pause = new BoolReactiveProperty(); // create UniRx ReactiveProperty to manage pausePowerObservables .CountedInterval(pause, tick: 1f) // you can provide the freqeuency of ticks .Subscribe(time =&amp;gt; { // every tick // 00:00 ... // 00:01 ... // 00:02 }) .AddTo(this); pause.Value = true; // interval will stopspause.Value = false; // interval will resume from previous pointUnity InstallationSince unity doesn’t support git dependencies in package.json you have to install UniRx manually.Edit manifest.json file in your Unity Packages directory{ &quot;dependencies&quot;: { &quot;com.gbros.tools.unirx.powerobservables&quot;: &quot;[&amp;lt;https://github.com/GbrosGames/Tools.git?path=Assets/UniRx/PowerObservables&amp;gt;](&amp;lt;https://github.com/GbrosGames/Tools.git?path=Assets/UniRx/PowerObservables&amp;gt;)&quot;, &quot;com.neuecc.unirx&quot;: &quot;[&amp;lt;https://github.com/neuecc/UniRx.git?path=Assets/Plugins/UniRx/Scripts&amp;gt;](&amp;lt;https://github.com/neuecc/UniRx.git?path=Assets/Plugins/UniRx/Scripts&amp;gt;)&quot; }}Unity ExamplesAll code samples can be found on our GitHub pageExample 1 - Counted IntervalThis example shows how to create Interval observable that will return TimeSpan in the cumulative way. It shows the way of refreshing the UI. It also shows use case for BoolReactiveProperty from UniRx library to manage pause/resume functionality.Example 2 — CountdownThis example shows how to create, restart and refresh Countdown and how to manage subscription and completion methods in observable.Where To Go From HereMessageBrokerResourcesUniRx Library" }, { "title": "UniRx Series — [Part 1] — MessageBroker", "url": "/posts/UniRx-Series-Part-1-MessageBroker/", "categories": "Unity", "tags": "Unity, UniRx, Intermediate", "date": "2021-03-06 00:00:00 +0100", "snippet": "This series will be highly related to UniRx libraryPrerequisites Familiar with Observer pattern Hands on any Rx libraryIntroductionMessageBroker is an in-memory publish/subscribe messaging system that provides event-driven, decoupled architecture in order to increase performance, reliability and scalability of your Unity application.It has three main components: Publisher of message — allows message to be broadcasted to the different parts of the application Receiver of message — receives the message produced by the publisher. MessageBroker — an orchestrator of all events.We will be using UniRx implementations. The API contains two main methods:IObservable&amp;lt;TMessage&amp;gt; MessageBroker.Default.Receive&amp;lt;TMessage&amp;gt;void MessageBroker.Default.Publish&amp;lt;TMessage&amp;gt;Where TMessage is a type we want to publish/receive.Receive method returns an observable, so we have to Subscribe in order to be notified by MessageBroker.Let’s go through a simple scenario, where we will aim to propagate a message across the game that something important has happened.MessageFirst let’s create our message class.To emphasize that our message can be anything, we will call our class GameEvent. Different approach surrounding types of objects that can be used here is described later in the article (see IMessage).To keep things simple, our GameEvent class will contain only Name property. We will also define two distinct types of our GameEvent (Dragon and HappyHours), which we will be able to reference later.public class GameEvent{ public const string Dragon = nameof(Dragon); public const string HappyHours = nameof(HappyHours); public string Name { get; } public GameEvent(string name) { Name = name; }}TIP — It’s good to avoid magic numbers and hard coded strings. One of the easiest way to do that is to create const properties and use “nameof()”. We can easily reference this value later.PublisherAfter that let’s publish a message:public class Player: MonoBehaviour{ // when the dragon appears in range of the player void OnDragonNoticed() { MessageBroker.Default.Publish(new GameEvent(GameEvent.Dragon)); }}ReceiversNow each game object that is interested in certain event has to subscribe through a receiver of our message object class:public class Villager : MonoBehaviour{ void Awake() { MessageBroker .Default .Receive&amp;lt;GameEvent&amp;gt;() .Where(x =&amp;gt; x.Name == GameEvent.Dragon) .Subscribe(_ =&amp;gt; Flee()) .AddTo(this); } void Flee() { // run as fast as possible }}This is where familiarity with Rx library comes in handy. As you can see, we do not have to create instance of our receiver (which is an observable). We simply query for our receiver message class type (of GameEvent), to filter out our game events by name, to finally subscribe against them. AddTo() method is crucial here: it links our subscription with Villager game object instance, ensuring proper life cycle when Villager gets destroyed (there are other methods that we could use to manage lifecycle, I left description on few of them in the good practices section).Now all villagers on the map will know that dragon is coming and they will run away to save their poor lives!Another good example is to use the same event in the AudioPlayer:public class AudioPlayer: MonoBehaviour{ void Awake() { MessageBroker .Default .Receive&amp;lt;GameEvent&amp;gt;() .Where(x =&amp;gt; x.Name == GameEvent.Dragon) .Subscribe(_ =&amp;gt; PlayGlobalEventSound()) .AddTo(this); }}Thanks to this our AudioPlayer component will also be notified about the same events and will play some intense music to inform the player that something important has happened.To summarize: when Player will notice the dragon, MessageBroker will publish GameEvent, and all Receivers will be notified.What is more, our subscribers (Villager and AudioPlayer components) which are listening to the same Dragon event, both will react in their own unique way.With this approach, we successfully decoupled our logic. Player MonoBehaviour don’t have to track any references to Villagers or AudioPlayer — and vice versa. Logic that we provided will be triggered automatically, so either Player, who is responsible here for noticing the dragon, or Villager or even AudioPlayer has to know about each other.Obviously there is many ways of handling such events. The one, that we just went through, is filtering observable by name.Now lets have a look at another good approach, which is to create a class for each event. Lets stay with the same context and declare DragonGameEvent and HappyHoursGameEvent (both inheriting from our GameEvent class):public class DragonGameEvent : GameEvent { }public class HappyHoursGameEvent : GameEvent { }This approach is making our solution to work on concrete types instead of string based names.Our Audio Player can now directly listen for the same event, but code gets simpler:public class AudioPlayer: MonoBehaviour { void Awake() { MessageBroker.Default.Receive&amp;lt;DragonGameEvent&amp;gt;(_ =&amp;gt; PlayDragonSound()); } }Alternatively, in case we need to identify more events or process additional data from event object, we can use pattern matching to identify what event has occurred:public class AudioPlayer: MonoBehaviour { void Awake() { MessageBroker .Default .Receive&amp;lt;GameEvent&amp;gt;(message =&amp;gt; PlaySound(gameEvent)) .AddTo(this); } void PlaySound(GameEvent gameEvent) { if (gameEvent is DragonGameEvent dragonEvent) { // play dragon event sound } }}This wraps up basics and idea behind them.If you want to learn more, below is ours, more practical, approach to utilize power hidden behind the MessageBroker.IMessageWe like to keep all requests as ScriptableObjects. Most of our Messages inherits from base Message class and implements simple IMessage interface, as below:/// &amp;lt;summary&amp;gt;/// Base class for ScriptableObject requests./// If you want to call MessageBroker from MonoBehaviours, call them directly -&amp;gt; Message.Create()/// ScriptableObject can&#39;t have constructors, try to add every Message through static Create method./// &amp;lt;/summary&amp;gt;public abstract class Message: ScriptableObject, IMessage{ [Button] [HideInEditorMode] public void Publish() { MessageBroker.Default.PublishMessage(this); }}If only Unity would support default interfaces we would be able to ignore base ScriptableObject class and use interface only. But for now we have to split it into base class and an interface.public interface IMessage{ void Publish();}Below is few useful extensions, so we don’t have to put Type into the angle brackets &amp;lt;&amp;gt; all the time.public static class MessageBrokerExtensions { public static IObservable&amp;lt;T&amp;gt; ReceiveMessage&amp;lt;T&amp;gt;(this IMessageBroker messageBroker) =&amp;gt; messageBroker.Receive&amp;lt;IMessage&amp;gt;().OfType&amp;lt;IMessage, T&amp;gt;(); public static void PublishMessage&amp;lt;T&amp;gt;(this IMessageBroker messageBroker, T message) where T : IMessage =&amp;gt; messageBroker.Publish&amp;lt;IMessage&amp;gt;(message); }Thanks to this setup, we don’t have to call Receive of Type every time we want to handle IMessage, of the given Type.It is a small improvement but it really makes life easier. To visualize the difference, this is before:MessageBroker.Default.Publish&amp;lt;IMessage&amp;gt;(message); // message.Publish();MessageBroker.Default.Receive&amp;lt;IMessage&amp;gt;().OfType&amp;lt;IMessage, GameEvent&amp;gt;();and after the changes:MessageBroker.Default.PublishMessage(message); // message.Publish();MessageBroker.Default.ReceiveMessage&amp;lt;GameEvent&amp;gt;();Additional benefit to using ScriptableObjects and a base class is keeping MessageBroker abstraction well separated. So if we would like to switch to different implementation or concept, we can easily do it in one place.Clean and simple right?After all this changes, our GameEvent message class, from the original example, would now look like this:public class GameEvent : Message{ public const string Dragon = nameof(Dragon); public const string HappyHours = nameof(HappyHours); [SerializeField] string name = default; public string Name =&amp;gt; name; public static GameEvent Create(string name) { var instance = CreateInstance&amp;lt;GameEvent&amp;gt;(); instance.name = name; return instance; }}TIP — ScriptableObjects can’t have constructors. Elegant way to bypass this, is adding static Create method and assigning values, as we usually do in the constructors.And our Player class, like thispublic class Player: MonoBehaviour{ // when the dragon appears in range of the player void OnDragonNoticed() { // before: // MessageBroker.Default.Publish(new GameEvent(GameEvent.Dragon)); // now: GameEvent.Create(GameEvent.Dragon).Publish(); }}Custom EditorThere is one more improvement to the whole thing, that is really worth mentioning.If you are using Odin Inspector (which we highly recommend), you can just put [Button] attribute above Publish() method in our base class. This will enable you to easily propagate Messages along all Receivers from the Inspector in the play mode.If you don’t have Odin Inspector (again, which we really recommend), you can use the following code:[CustomEditor(typeof(Message), editorForChildClasses: true)] public class Messageditor : Editor { public override void OnInspectorGUI() { DrawDefaultInspector(); if (!Application.isPlaying) return; if (!(target is IMessage message)) return; if (!GUILayout.Button(nameof(IMessage.Publish))) return; message.Publish(); } }Thanks to all of this, we can now create Message assets in our project, and test our system by clicking “Publish” button to debug certain functionality.It helps us to keep our messages organized. Debugging is easy. And whole game development process is much more comfortable.UtilitiesYou can also create many utilities based on ScriptableObjects and the Messages system.Another utility which is pretty handy is component that allows you to activate GameObject after certain message is received:/// &amp;lt;summary&amp;gt;/// Activates game object when receive Message /// &amp;lt;/summary&amp;gt;public abstract class ActivateOnMessage&amp;lt;T&amp;gt; : MonoBehaviour where T : Message{ // the message itselft so we can reference it from the inspector [SerializeField] protected T message; // condition that has to be met to activate an object // this declaration allows to change base function in case different filtration is needed protected virtual Func&amp;lt;T, bool&amp;gt; predicate =&amp;gt; incomingMessage =&amp;gt; incomingMessage.GetType() == message?.GetType(); public virtual void Awake() { this.gameObject.SetActive(false); MessageBroker .Default .ReceiveMessage&amp;lt;T&amp;gt;() .Where(predicate) .Subscribe(x =&amp;gt; gameObject.SetActive(true)) .AddTo(this); }}// general class that will activate object when any referenced message of type Message is receivedpublic class ActivateOnMessage : ActivateOnMessage&amp;lt;Message&amp;gt; { }When attached to a GameObject, above component looks like this:Good place to take advantage of the above utility is to manage our game loop.Lets say we have a game manager that is propagating game loop events like GameStart, GameEnd, GameWon, GameLost etc. With our utility tool we can easily Activate / Deactivate certain GameObjects by adding ActivateOnMessage component to GameObjects associated with our game loop.What’s more, we have marked our ActivateOnMessage class as Generic. This gives us ability to switch base Type and to override predicates in more complex scenarios.For example if we add ActivateOnMessage component we can reference any kind of Message as our base predicate is comparing only type of incoming message and the value referenced from the inspector:protected virtual Func&amp;lt;T, bool&amp;gt; predicate =&amp;gt; incomingMessage =&amp;gt; incomingMessage.GetType() == message?.GetType();In order to filter GameEvents, like in our initial examples (by name), now we only need to simply create a class that inherits from ActivateOnMessage. Through usage of generic types we can reference any properties and create custom conditions:public class ActivateOnGameEvent : ActivateOnMessage&amp;lt;GameEvent&amp;gt;{ protected override Func&amp;lt;GameEvent, bool&amp;gt; predicate =&amp;gt; incomingMessage =&amp;gt; incomingMessage.Name == message.Name;}And component like this:That being said, in 90% of cases, we simply use ActivateOnMessage and instead do filtering through properties, we filter them by type:public class DragonGameEvent : GameEvent { }public class HappyHoursGameEvent : GameEvent {}Key take-away here is that it is much easier to maintain strongly typed messages. Otherwise you would end up hardcoding tons of settings in the inspector of many GameObjects scattered across whole solution. Which is not scaling well and is prone to human errors.Unity Code SamplesAll code samples can be found on our GitHub pageExample 1 — Color SwitcherIn this example we will use MessageBroker as simple example of code decoupling.We will create :ColorSwitchMessage — message as a request to switch colorColorGenerator component, that will generate new ColorSwitchMessage with random color whenever space bar is pressedColorSwitcher — object that will switch its color whenever receives ColorSwitchMessageExample 2 — Color Switcher with ScriptableObject request messagesIn this example we will improve our code and extract Message into ScriptableObject.Example 3 — Zone ChangeIn this example we will see how to manage and decouple Game logic from UI by using Messages.We will extract abstraction for our Messages and use IMessage class.Example 4 — Activate on MessageIn this example we will create generic components to activate messages of given type.We will create countdown that publishes Game Start Message and activates the Player with utility component.Good PracticesLastly, lets make notes around few good practices that are worth mentioning here: It’s good to avoid magic numbers and hard coded strings. One of the greatest way is to create const property and use “nameof()”. We can easily reference this value later. ScriptableObjects can’t have constructors. We can replace it in elegant way by creating static Create method and assign values as usual in constructors. Lifecycle: remember to dispose subscriptions of your observables by using TakeWhile, TakeUntil, TakeUntilDestroy and TakeUntilDisable or simply add .AddTo(this) when you are in MonoBehaviour to prevent execution if component is destroyed that may leading to unexpected behavioursWhere To Go From HereThis is first part of the article about UniRx. If you are interested, be sure to check next part that will cover in details the monitors.All related scripts (and more!) can be found in our examples repository, so please give it a try!Finally If you want to do more reading check resources section!Resources The introduction to Reactive Programming you’ve been missing Practical Rx Training UniRx Library Reactive manifesto" }, { "title": "Stateless in Unity", "url": "/posts/Stateless-in-Unity/", "categories": "Unity", "tags": "Unity, Intermediate", "date": "2021-02-09 00:00:00 +0100", "snippet": "Prerequisites Familiar with state pattern Hands on events Hands on genericsIntroductionWe were looking for lightweight solution for managing state of entities in Unity. We placed our bet on Stateless.NET library that we used previously during development of .NET Applications. It’s a nice and lightweight library under Apache 2.0 License.Why stateless? Flexible Lightweight Hierarchical States Possibility to reenter the state Entry/Exit and Activation events Guard clauses — for easy rules definition Graph preview Easy to read and maintainUnity InstallationOpen NuGet package manager and search for StatelessAfter installation, copy Stateless.dll and Stateless.xml from YourProject\\Packages\\Stateless.5.1.2\\lib\\netstandard2.0Create folder for external, non-unity packages in Assets directory. It may be something like\\Assets\\Libraries\\Stateless\\and paste files there.Now we are ready to go! :)How To UseLet’s create our Chest class and define our Trigger and State types:public class Chest : MonoBehaviour{ public enum State { Opened, Closed } public enum Trigger { Open, Close }}Basic approach is to define representation of State as Enums, but thanks to generic types it can be everything, even MonoBehaviours.It’s also good to define states and triggers directly in the class so we will avoid possibility of name duplication while creating our state machines. After that we can create our StateMachine. Let’s do it in Awake method.private StateMachine&amp;lt;State, Trigger&amp;gt; stateMachine;private void Awake(){ stateMachine = new StateMachine&amp;lt;State, Trigger&amp;gt;(State.Closed); stateMachine .Configure(State.Opened) .OnEntry(OnChestOpened) .Permit(Trigger.Close, State.Closed); stateMachine .Configure(State.Closed) .OnEntry(OnChestClosed) .Permit(Trigger.Open, State.Opened);}We have to call Configure method on every state to set up rules and relations between our states. After that we can define what actions can be performed during each state. Most common methods used during configuration for state machines are: OnEntry / OnExit — accepts Action which will be triggered on state enter / exit OnEntryFrom — accepts Action which we want to perform after a transition from a certain state Permit — the main method where we specify a valid state transition based on a trigger PermitIf — as above with so called Guard (boolean function) SubstateOf — method which sets parent stateLets look at the following example, where we are configuring state Opened and we are permitting Trigger Close to be called, after which state machine will transition its state to Closed:stateMachine .Configure(State.Opened) .Permit(Trigger.Close, State.Closed);Next we will configure state Closed. This time with the use of PermitIf . It is almost the same as above Permit function, but with ability to set up the Guard Clause — which will act as a Rule that will tell us whether we can enter triggered state or not:stateMachine .Configure(State.Closed) .PermitIf(Trigger.Open, State.Opened, () =&amp;gt; player.HasEpicKeyInInventory());Lastly lets use SubstateOf — method which allows us to define hierarchy of States. We will use it for locked state, and we will set it as a sub-state of state closed:stateMachine .Configure(State.Locked) .SubstateOf(State.Closed)To check in which sate our machine currently is, we can call IsInState method. But this check also honours state hierarchy. So if our state machine would be in State.Locked and we would do check for State.ClosedstateMachine.IsInState(State.Closed);the answer would be true.Ok now lets see how we can harness benefits of using state machines! But first lets summarize what we did and what it gives us: We have created state machine for our Chest We have described that at any time Chest enters the state Opened the OnChestOpened action will be invoked We have also permitted our Trigger.Close to happen with destination state of ClosedAs you can see we didn’t write a single if statement here. For everyone that loves “clean code” or “less code” approach its already huge benefit.Now let explore what potential advantages it gives us when we are constructing complicated state machines.First of all it minimizes conditional complexity and eliminating the need for if and switch statements.private void OnChestClosed(){ // play close animation // play close sound}private void OnChestOpened(){ // play open animation // play open sound}Secondly we can easily, extend the API for our Chest class by exposing public methods with ability to trigger its state changing logic:public void Open(){ if (!stateMachine.CanFire(Trigger.Open)) return; stateMachine.Fire(Trigger.Open);}public void Close(){ if (!stateMachine.CanFire(Trigger.Close)) return; stateMachine.Fire(Trigger.Close);}Please note that before firing specific trigger, we are validating if we have a permission to fire this trigger from current state.Firing a trigger that does not have an allowed transition associated with it will cause an exception to be thrown. To prevent that, simply register some default behaviour and override exception through OnUnhandledTrigger() method:stateMachine.OnUnhandledTrigger((state, trigger) =&amp;gt; { Debug.Log($&quot;Unhandled trigger {trigger} can&#39;t befired from state {state}&quot;); });Last thing that is really great about stateless is that your state machine can be visualized as a graph. Be sure to check Samples section below to learn more and get info where to find some code examples!Graph PreviewThe big advantage of using Stateless .NET is that you can easily visualize your state machine. To serialize your state machine to standard text-based DOT format, you have to call stateMachine GetInfo() method:var graphVisualization = UmlDotGraph.Format(stateMachine.GetInfo());Copy graphVisualization variable value and paste it on the here — to see how the graph looks like. Obviously, if someone deems it necessary, this can be easily incorporated into unity through the custom editor script.Unity Code SamplesAll code samples can be found on our GitHub pageExample 1 — ChestThe chest example with Key Code enum as a trigger. It works like a toggle. Whenever we press a Space bar the chest will open if it’s closed or will close if it’s opened. It’s the most simplistic example that shows us base usage of Stateless library.Example 2 — ChestIn this example we take whole idea from Example 1 a step further and we add custom trigger to open and close our chest. It’s good practice to nest State and Trigger inside the subject class, so we can avoid the name conflicts in case of multiple states and triggers are present in our project. We can refer to Chest state or trigger enum by calling it Chest.State / Chest.Trigger.Example 3 — ChestIn this example we will learn how to improve our code even further. We’ve exposed the public events that are triggered whenever the chest is open or closed. By doing that we have decoupled our animations from the Chest class itself. We’ve created the ChestAnimation component which is responsible just for playing animations. We do it cause It’s not the Chest component responsibility to do all of those things. Another key take-away — it’s good to subscribe to events in OnEnable / OnDisable methods:private void OnEnable(){ chest.ChestClosed += OnChestClosed; chest.ChestOpened += OnChestOpened;}private void OnDisable(){ chest.ChestClosed -= OnChestClosed; chest.ChestOpened -= OnChestOpened;}Now we have fully modular solution. We can add another component like ChestSound, ChestParticles, ChestReward etc.Example 4 — Interactables — just to show what can be done betterIn this example we have added simple Player and two chests with overlapping areas.We have removed Update method, which was listening for input, from Chest — because it’s not the Chest responsibility to manage user input. Instead of this, we’ve created Input Monitor with only one job: to gather user input. With this approach we can easily connect or replace this input system to a different one.We’ve also added Interaction Monitor. It is registering every Interactables that can be interacted with whenever Player enters an interaction area. We have also created IInteractable interface and we extended Chest API by implementing it.With this approach we are able to extend our system with ease. For example we can implement interface IInteractable in other places like Loot, Levers, Doors, and our Interaction Monitor will pick those up and handle all the communication between those components.Good PracticesLastly, lets make notes around few good practices that are worth mentioning here: Nest enum States and Triggers inside the subject class to avoid name conflicts in your solution If you are creating states as separated classes, pass stateMachine Controller class to the constructor Subscribe to events inside OnEnable method, and unsubscribe them in OnDisableWhere To Go From HereIn the incoming blog posts we will like to share more techniques, that we’ve found useful, while working with reactive state machines in our projects. We really hope that more developers can take benefit from using state machines and incorporate them into their toolbox.All related scripts (and more!) can be found in our examples repository, so please give it a try!Finally If you want to do more reading check resources section!ResourcesOfficial Stateless RepositoryReally good introduction to Stateless library by S. HenselmanGreat read about state pattern" } ]
